/*
 * This is a input demultiplexor class
 */
requires 2.0.0
%{
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#include <unistd.h>
#include <debug_macros.h>
#include <gio/gio.h>
#include <rgi.pb-c.h>
#include "rgi-stateparam.h"
#include "rgi-pwmparam.h"
#include "rgi-adcparam.h"
%}

%headertop{
#include <gio/gio.h>
#include "rgi-usbscheduler.h"
%}

%{
  typedef struct _idclient
  {
    unsigned int id;
    int exclusive;
  } idclient; //input demultiplexor client
  typedef int (*h)(RgiInputDemultiplexor *, void*, unsigned int, GDataInputStream *, GDataOutputStream*);
  typedef struct _idphandler
  {
    unsigned int id;
    h callback;
  } idphandler;

  static gboolean
    handler (GThreadedSocketService *service,
	     GSocketConnection      *connection,
	     GSocketListener        *listener,
	     gpointer                user_data)
  {
    GOutputStream *out;
    GInputStream *in;
    GFileInputStream *file_in;
    GDataInputStream *idata;
    GDataOutputStream *odata;
    char *line, *escaped, *tmp, *query, *unescaped, *path, *version;
    GFile *f;
    GError *error;
    GFileInfo *info;
    GString *s;

    RgiInputDemultiplexor * self = (RgiInputDemultiplexor * )user_data;
    RgiUsbScheduler * me = self->scheduler;
    
    gboolean ret = FALSE;
    
    in = g_io_stream_get_input_stream (G_IO_STREAM (connection));
    out = g_io_stream_get_output_stream (G_IO_STREAM (connection));
    
    idata = g_data_input_stream_new (in);
    odata = g_data_output_stream_new (out);
    
    pmsg ("handler called \n");
    
    g_data_input_stream_set_byte_order (idata, G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN);
    GError *tmp_error;
    int noway = 0;
    while (noway == 0)
      {
	unsigned short head = g_data_input_stream_read_int16 (idata, NULL, NULL);
	if (tmp_error!= NULL)
	  {
	    pmsg("%s\n", tmp_error->message);
	    noway = 1;
	    break;
	  }
	pmsg ("packettype = %i\n", head);
	unsigned short len = g_data_input_stream_read_int16 (idata, NULL, &tmp_error);
	if (tmp_error!= NULL)
	  {
	    pmsg("%s\n", tmp_error->message);
	    noway = 1;
	    break;
	  }
	pmsg ("packetlen = %i\n", len);
	
	unsigned char * packed = malloc(len);
	for (int i = 0; i<len; i++)
	  {
	    packed[i] = g_data_input_stream_read_byte (idata, NULL, NULL);
	    if (tmp_error!= NULL)
	      {
		pmsg("%s\n", tmp_error->message);
		noway = 1;
		break;
	      }
	  }
	if (noway==0)
	  {
	    idphandler * idph = (idphandler*)g_hash_table_lookup(self->_priv->packethandlers, (void*)&head);
	    
	    if (idph != NULL)
	      {
		idph->callback(self, packed, len, idata, odata);
	      }
	  }
      }
    
    g_object_unref (idata);
    g_object_unref (odata);
  }
%}

class Rgi:InputDemultiplexor from G:Object
{
  public GAsyncQueue* fromusb;
  public GAsyncQueue* tousb;
  public RgiUsbScheduler * scheduler;
  private GHashTable * clients;
  private GHashTable * packethandlers;

  public 
    int 
    setpwm(self, void * data, unsigned int len, GDataInputStream *idata, GDataOutputStream *odata)
  {
    Rgi__Setpwmchan *pwmchan;
	
    pwmchan = rgi__setpwmchan__unpack(NULL, len, data);

    if (pwmchan->channel > 2)
      return -1;
    pmsg("pwmchan->value = %i", pwmchan->value);
    pmsg("pwmchan->channel = %i", pwmchan->channel);
    pwmdata p;
    p.valuesw[pwmchan->channel] = pwmchan->value;
    RgiStateParam * param = rgi_usbscheduler_getparam(self->scheduler, PER_PWM);
    rgi_stateparam_set(param, &p);
  }

  public 
    int 
    getadc(self, void * data, unsigned int len, GDataInputStream *idata, GDataOutputStream *odata)
  {
    Rgi__Getadcchannel *adcchan;
	
    adcchan = rgi__getadcchannel__unpack(NULL, len, data);

    if (adcchan->channel > 8)
      return -1;
    pmsg("adcchan->channel = %i", adcchan->channel);
    RgiStateParam * param = rgi_usbscheduler_getparam(self->scheduler, PER_ADC);
    adcdata * p = rgi_stateparam_get(param);

    Rgi__Telladcchannel telladcchan = RGI__TELLADCCHANNEL__INIT;
    telladcchan.channel = adcchan->channel;
    telladcchan.value = p->adcval[adcchan->channel];
    int sz = rgi__telladcchannel__get_packed_size(&telladcchan);
    char * buffer = (char*)malloc(sz*(sizeof(char)));
    rgi__telladcchannel__pack(&telladcchan, buffer);
    g_data_output_stream_put_int16(odata, PER_TELLADC, NULL, NULL);
    g_data_output_stream_put_int16(odata, sz, NULL, NULL);
    for (int i = 0; i<sz; i++)
      g_data_output_stream_put_byte(odata, buffer[i], NULL, NULL);
    
    free (buffer);
  }

  init(self)
  {
    self->_priv->packethandlers = g_hash_table_new(g_int_hash, g_int_equal);
  }

  public
  void
  start(self)
  {
    pmsg("starting init sequence\n");
    GSocketService *service;
    GOptionContext *context;
    GError *error = NULL;

    idphandler * pwm = malloc(sizeof(idphandler));
    pwm->id = PER_PWM;
    pwm->callback = rgi_inputdemultiplexor_setpwm;
    g_hash_table_insert(self->_priv->packethandlers, &(pwm->id),pwm);

    idphandler * adc = malloc(sizeof(idphandler));
    adc->id = PER_GETADC;
    adc->callback = rgi_inputdemultiplexor_getadc;
    g_hash_table_insert(self->_priv->packethandlers, &(adc->id),adc);
    
    context = g_option_context_new ("RGI server");

    pmsg("creating service\n");    
    service = g_threaded_socket_service_new (10);
    if (!g_socket_listener_add_inet_port (G_SOCKET_LISTENER (service),
					  30000,
					  NULL,
					  &error))
      {
	pmsg ("failed to add inet port\n");
	return;
      }
    
    pmsg ("RGI Input Demultiplexor is listening on port %d\n", 30000);
    
    g_signal_connect (service, "run", G_CALLBACK (handler), G_OBJECT(self));
    
    g_main_loop_run (g_main_loop_new (NULL, FALSE));

    GHashTableIter iter;
    int * key;
    idphandler * value;
    g_hash_table_iter_init(&iter, self->_priv->packethandlers);
    while (g_hash_table_iter_next (&iter, (void**)&key, (void**)&value)) 
      {
	free(value);
      }
    g_hash_table_destroy(self->_priv->packethandlers);
    g_assert_not_reached ();
  }

  public RgiInputDemultiplexor *
    new (void)
  {
    return (RgiInputDemultiplexor *)GET_NEW;
  }
  
}
